package com.learn.kotlin.day01

/**
 * @author shuimu{lwp}
 * @time 2019/8/14  11:59
 * @desc 资料来源：https://www.cnblogs.com/Jetictors/p/8031291.html
 */
/**
 * kotlin的声明函数格式：
 * fun 函数名(参数名:参数类型,参数名:参数类型...):返回值类型 {
...函数体...
 * }
 *注意： 当函数没有返回值时,返回值的类型为Unit,也可以忽略不写。
 *
 * kotlin的方法重载方式：
 * 在定义函数时,可以给函数的参数定义默认值，当该参数没有传值时,则传递默认值。
 * 函数参数的默认值写法:
 * fun 函数名(参数名:参数类型=默认值,参数名:参数类型):返回值类型{}
 * 需要注意的点:当父类定义了有参数默认值的函数之后,子类是不允许重写父类该函数之后进行参数默认值重写,子类无法进行参数默认值重写的,而且编译器也会报错误
 * 子类可以重写该函数但不能重写参数默认值。
 *
 * kotlin中的 特殊语法:单表达式函数
 * 我们定义函数的时候，当函数的 函数体只有表达式时,是可以省略花括号，直接用=等号的，
 * 表达式的定义: 单个常量,单个字符串常量,单个Boolean值，一个运算公式,一组有返回结果的逻辑都能算是表达式。
 * 例如：fun test01()="nihao" 这个函数(1)函数体只有一行代码,所以省略了花括号
 * (2)函数体中的这行代码,原本只是写了个字符串常量而已,当省略了花括号后,它被看做是表达式
 * fun test01():Noting=return
 * (1)省略花括号,用=号代替(2)return关键字被看成了表达式
 *
 * kotlin的不定参数
 * java的不定参数是三个点"..."，kotlin的不定参数 通过 varary 关键字表示。
 * 声明不定参数的格式：varary 不定参数名:不定参数类型
 *
 * 示例：fun test(varary arr:String){ 略}
 *
 * kotlin的 尾递归函数
 * kotlin中tairec修饰符修饰的方法就是尾递归函数，但是要被tairec修饰必须满足一个条件就是 函数内部的逻辑代码，要有部分逻辑是以“调用其自身”作为结束时，才可以使用。
 * 也就是 只有你这个方法是真的能形成 递归的逻辑才可以用这个tairec关键字进行修饰。
 *
 * kotlin中的 高阶函数
 * 高阶函数就是该函数的入参是一个函数,或者该函数的返回值是一个函数,以一个函数作为入参或作为返回值的函数就是高阶函数。
 * 例如：fun returnFun(): (Int, Int) -> Int {
return { j, i -> j + i }
}
 * 示例中就是一个高阶函数，因为他的返回值是返回一个"有两个int入参,返回值是int类型的函数"
 *
 * kotlin 的 闭包函数
 * 闭包函数就是能够读取或持有 “声明其存在的函数中的内部变量,内部状态"的函数。
 * 例如：
fun closureMethod(i: Int): () -> Unit {
     var memoryValue = 1
      return fun(): Unit { memoryValue++ }
}
 *上面的函数中,closureMethod(i:Int):()->Unit{}函数不是闭包函数，闭包函数是其里面 声明的 fun():Unit{} 函数,它才是闭包函数。
 * 闭包函数 fun():Unit{} 中 能够访问其声明所在函数 closureMethod(i:Int):()->Int{}函数 的内部变量memoryValue，当调用closureMethod()方法时,
 * 该方法返回闭包函数 fun():Unit{},我们拿着"闭包函数 fun():Unit{}"去执行,这时注意:既然闭包函数作为返回值从closureMethod()中返回出来了,那么closureMethod()应该已经出栈了,那么closureMethod()
 * 中的资源被回收了,但其内声明的内部变量memoryValue(函数内部状态)则是被闭包函数持有了。闭包函数能够继续正常执行。
 *
 * kotlin的匿名函数
 * 没有方法名的函数就是匿名函数。声明方法的格式：fun 函数名(参数名:参数类型...):返回值类型{}。
 * 声明匿名函数的话因为没有函数名,因此会把匿名函数当作一个表达式,把匿名函数赋值给一个变量或者常量来持有,我们通过这个变量/常量来使用该匿名函数
 * 这种形式就叫:"函数字面值"
 * 示例：val methods=fun(){} ; methods()
 * 声明了 一个匿名函数并把它赋值给了methods常量,通过常量进行调用匿名函数执行。
 *
 * kotlin的函数字面量。
 * 声明函数字面量的格式：
 * 把[匿名函数]或[lambda表达式]赋值给变量,称为函数字面量/函数字面值。
 * 例如：var p1 = {a:String,b:String -> a.length < b.length};声明了一个lambda表达式并赋予给p1变量，这样就完成了函数字面量定义

 * "带接收者的函数字面量"声明:val 变量名= fun 类名.(参数列表){};可以看作是给[类声明一个匿名拓展函数]
 * 例如：
 * fun test03(block: Book.() -> Unit){
 *     //调用方式一:把"带接收者的函数字面量"当作普通函数调用时,必须给其传入一个"接收者类型的实例"作为参数
 *     block(Book())
 *     //调用方式二:创建接收者类型的实例，然后把"带接收者的函数字面量"当作拓展函数使用
 *     Book().block()
 * }
 * "带接收者的函数字面量"的特性：
 * (1) block:Book.()->Unit看起来像是给Book类声明了一个"无参数无返回值的匿名拓展函数",但其实()->Unit是有参数的,需要传入一个参数类型为接收者类型的对象。
 * 例如对于声明的"block:Book.()->Unit"带接收者函数字面量我们可以这样调用:block(Book()); 对的没看错.需要传入接收者类型的对象。当然另一种写法的话,可以不传。
 * (2)对于带接收者函数字面量,如果不传递"接收者类型的对象"这个参数的话,那也需要先创建一个 接收者类型的对象,然后把"带接收者函数字面量"当作拓展函数调用即可。
 * 例如:对于声明的"block:Book.()->Unit"带接收者函数字面量我们可以这样调用:Book().block()。对的没看出,需要创建接收者类型的对象,然后当作拓展函数使用。
 * 因为函数字面值和拓展函数声明比较像，特此提醒：
 * 声明拓展函数为:类名.函数名(参数列表){}
 * 声明函数字面值为：类名.(参数列表){}
 * 对，两者差别就是【有没有函数名】
 *
 * kotlin中的命名参数
 * 命名函数其实只是为了方便编程时查看每个参数具体是什么含义而出现的，原本我们调用一个函数给函数传入参数的时候只需要传参数值即可
 * 但是为了能够方便的看出每个参数值的含义，可以把函数的参数名带上(参数名=参数值)这种方式来写传入的参数，会更友好一点
 * 例如：
 * 定义一个函数:fun test01(name:String,age:Int){};
 * 普通调用方式是直接传参数值：test01(“小明”,18)
 * 使用命名参数的形式传参数值：test01(name=“小明”,age=18)
 * 可以看出,命名参数的方式比较友好，仅此而已。
 * */
class KnowledgePoints03 {

    fun test01(name: String, age: Int) {
    }

    fun test02(): Unit {
        test01(name = "小明", age = 18)
    }

    fun test03(block: Book.() -> Unit) {
        block(Book("宇宙大爆炸起源", "100元", "科技出版社"))
        Book().block()
    }
}

fun methodsA(): () -> Unit {
    var testValue = 1
    val tempMethods = fun() {
        testValue++
        println(testValue)
    }
    return tempMethods
}

fun main() {
    val methodsB = methodsA()
    methodsB()
    methodsB()
    methodsB()
}

val sentTo = fun Book.() {}
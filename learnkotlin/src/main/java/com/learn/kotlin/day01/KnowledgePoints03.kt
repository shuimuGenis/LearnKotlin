package com.learn.kotlin.day01

/**
 * @author shuimu{lwp}
 * @time 2019/8/14  11:59
 * @desc 资料来源：https://www.cnblogs.com/Jetictors/p/8031291.html
 */
/**
 * kotlin的声明函数格式：
 * fun 函数名(参数名:参数类型,参数名:参数类型...):返回值类型 {
...函数体...
 * }
 *注意： 当函数没有返回值时,返回值的类型为Unit,也可以忽略不写。
 *
 * kotlin的方法重载方式：
 * 在定义函数时,可以给函数的参数定义默认值，当该参数没有传值时,则传递默认值。
 * 函数参数的默认值写法:
 * fun 函数名(参数名:参数类型=默认值,参数名:参数类型):返回值类型{}
 * 需要注意的点:当父类定义了有参数默认值的函数之后,子类是不允许重写父类该函数之后进行参数默认值重写,子类无法进行参数默认值重写的,而且编译器也会报错误
 * 子类可以重写该函数但不能重写参数默认值。
 *
 * kotlin中的 特殊语法:单表达式函数
 * 我们定义函数的时候，当函数的 函数体只有表达式时,是可以省略花括号，直接用=等号的，
 * 表达式的定义: 单个常量,单个字符串常量,一个运算公式,一组有返回结果的逻辑都能算是表达式。
 * 例如：fun test01()="nihao" 这个函数(1)函数体只有一行代码,所以省略了花括号
 * (2)函数体中的这行代码,原本只是写了个字符串常量而已,当省略了花括号后,它被看做是表达式
 * fun test01():Noting=return
 * (1)省略花括号,用=号代替(2)return关键字被看成了表达式
 *
 * kotlin的不定参数
 * java的不定参数是三个点"..."，kotlin的不定参数 通过 varary 关键字表示。
 * 声明不定参数的格式：varary 不定参数名:不定参数类型
 *
 * 示例：fun test(varary arr:String){ 略}
 *
 * kotlin的 尾递归函数
 * kotlin中tairec修饰符修饰的方法就是尾递归函数，但是要被tairec修饰必须满足一个条件就是 函数内部的逻辑代码，要有部分逻辑是以“调用其自身”作为结束时，才可以使用。
 * 也就是 只有你这个方法是真的能形成 递归的逻辑才可以用这个tairec关键字进行修饰。
 *
 * kotlin中的 高阶函数
 * 高阶函数就是该函数的入参是一个函数,或者该函数的返回值是一个函数,以一个函数作为入参或作为返回值的函数就是高阶函数。
 * 例如：fun returnFun(): (Int, Int) -> Int {
return { j, i -> j + i }
}
 * 示例中就是一个高阶函数，因为他的返回值是返回一个"有两个int入参,返回值是int类型的函数"
 *
 * kotlin 的 闭包函数
 * 闭包函数就是能够读取“声明其存在的函数"的 内部变量的函数。
 * 例如：fun closureMethod(i: Int): () -> Int {
var memoryValue = 1
return fun(): Int {
return i + memoryValue++
}
}
 *上面的函数中,closureMethod(i:Int):()->Int{}函数不是闭包函数，闭包函数是其里面 声明的 fun():Int{} 函数,它才是闭包函数。
 * 因此在 fun():Int{} 中 能够访问其声明所在函数 closureMethod(i:Int):()->Int{}函数 的内部变量
 *
 * kotlin的匿名函数
 * 没有方法名的函数就是匿名函数。声明方法的格式：fun 函数名(参数名:参数类型...):返回值类型{}。
 * 声明匿名函数的话因为没有函数名,因此会把匿名函数当作一个表达式,把匿名函数赋值给一个变量或者常量来持有,我们通过这个变量/常量来使用该匿名函数
 * 示例：val methods=fun(){} ; methods()
 * 声明了 一个匿名函数并把它赋值给了methods常量,通过常量进行调用匿名函数执行。
 *
 * kotlin的函数字面量。
 * 把匿名函数或lambda表达式赋值给一个变量,这就是 函数字面量/函数字面值。
 * 例如：var p1 = {a:String,b:String -> a.length < b.length};声明了一个lambda表达式并赋予给p1变量，这样就完成了函数字面量定义
 * 另一种是："带接收者的函数字面量"
 * var test6:Int.(other:Int)->Int = {
 *     other->
 *        plus(other) //这里就是没有使用额外的限定符直接调用接收者对象的方法，等价于 this.plus(other)
 *        other + this //最后一句即为返回值
 * }
 *
 * kotlin中的命名参数
 * 命名函数其实只是为了方便编程时查看每个参数具体是什么含义而出现的，原本我们调用一个函数给函数传入参数的时候只需要传参数值即可
 * 但是为了能够方便的看出每个参数值的含义，可以把函数的参数名带上(参数名=参数值)这种方式来写传入的参数，会更友好一点
 * 例如：
 * 定义一个函数:fun test01(name:String,age:Int){};
 * 普通调用方式是直接传参数值：test01(“小明”,18)
 * 使用命名参数的形式传参数值：test01(name=“小明”,age=18)
 * 可以看出,命名参数的方式比较友好，仅此而已。
 * */
class KnowledgePoints03 {

    fun test01(name: String, age: Int) {
    }

    fun test02() {
        test01(name = "小明", age = 18)
    }
}
package com.learn.kotlin.day01

/**
 * @author shuimu{lwp}
 * @time 2019/8/14  11:59
 * @desc 资料来源：https://www.cnblogs.com/Jetictors/p/8031291.html
 */
/**
 * kotlin的声明函数格式：
 * fun 函数名(参数名:参数类型,参数名:参数类型...):返回值类型 {
...函数体...
 * }
 *注意： 当函数没有返回值时,返回值的类型为Unit,也可以忽略不写。
 *
 * kotlin的方法重载方式：
 * 在定义函数时,可以给函数的参数定义默认值，当该参数没有传值时,则传递默认值。
 * 函数参数的默认值写法:
 * fun 函数名(参数名:参数类型=默认值,参数名:参数类型):返回值类型{}
 * 需要注意的点:当父类定义了有参数默认值的函数之后,子类是不允许重写父类该函数之后进行参数默认值重写,子类无法进行参数默认值重写的,而且编译器也会报错误
 * 子类可以重写该函数但不能重写参数默认值。
 *
 * kotlin中的 特殊语法:单表达式函数
 * 我们定义函数的时候，当函数的 函数体只有表达式时,是可以省略花括号，直接用=等号的，
 * 表达式的定义: 单个常量,单个字符串常量,一个运算公式,一组有返回结果的逻辑都能算是表达式。
 * 例如：fun test01()="nihao" 这个函数(1)函数体只有一行代码,所以省略了花括号
 * (2)函数体中的这行代码,原本只是写了个字符串常量而已,当省略了花括号后,它被看做是表达式
 * fun test01():Noting=return
 * (1)省略花括号,用=号代替(2)return关键字被看成了表达式
 *
 * kotlin的不定参数
 * java的不定参数是三个点"..."，kotlin的不定参数 通过 varary 关键字表示。
 * 声明不定参数的格式：varary 不定参数名:不定参数类型
 *
 * 示例：fun test(varary arr:String){ 略}
 *
 * kotlin的 尾递归函数
 * kotlin中tairec修饰符修饰的方法就是尾递归函数，但是要被tairec修饰必须满足一个条件就是 函数内部的逻辑代码，要有部分逻辑是以“调用其自身”作为结束时，才可以使用。
 * 也就是 只有你这个方法是真的能形成 递归的逻辑才可以用这个tairec关键字进行修饰。
 *
 * kotlin中的 高阶函数
 * 高阶函数就是该函数的入参是一个函数,或者该函数的返回值是一个函数,以一个函数作为入参或作为返回值的函数就是高阶函数。
 * 例如：fun returnFun(): (Int, Int) -> Int {
return { j, i -> j + i }
}
 * 示例中就是一个高阶函数，因为他的返回值是返回一个"有两个int入参,返回值是int类型的函数"
 *
 * kotlin 的 闭包函数
 * 闭包函数就是能够读取“声明其存在的函数"的 内部变量的函数。
 * 例如：fun closureMethod(i: Int): () -> Int {
var memoryValue = 1
return fun(): Int {
return i + memoryValue++
}
}
 *上面的函数中,closureMethod(i:Int):()->Int{}函数不是闭包函数，闭包函数是其里面 声明的 fun():Int{} 函数,它才是闭包函数。
 * 因此在 fun():Int{} 中 能够访问其声明所在函数 closureMethod(i:Int):()->Int{}函数 的内部变量
 *
 * kotlin的匿名函数
 * 没有方法名的函数就是匿名函数。声明方法的格式：fun 函数名(参数名:参数类型...):返回值类型{}。
 * 声明匿名函数的话因为没有函数名,因此会把匿名函数当作一个表达式,把匿名函数赋值给一个变量或者常量来持有,我们通过这个变量/常量来使用该匿名函数
 * 示例：val methods=fun(){} ; methods()
 * 声明了 一个匿名函数并把它赋值给了methods常量,通过常量进行调用匿名函数执行。
 * */
class KnowledgePoints03 {

}
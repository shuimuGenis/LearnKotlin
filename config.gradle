class SayHelloTask extends DefaultTask {
    //定义在task中的字段就是改task的属性，通过task的setProperty("属性名",值)来设置属性
    String msg = "say hellot"
    int age = 20

    @TaskAction
    void sayAction() {
        println "位于生命周期:execution阶段，打印内容为:  the class msg : $msg ,age is $age"
    }
}

task test01(group: "studyGradle") {
    doLast {
        println "test01 is exec..."
    }
}

task test02(group: "studyGradle") {
    doLast {
        println "test02 is exec..."
    }
}

task test03(group: "studyGradle") {
    doLast {
        println "test03 is exec..."
    }
}

task hello01(type: SayHelloTask, group: "studyGradle") {
    println "the task group :${getGroup()}"
}
hello01.configure {
    println "Task的生命周期是: initialization-->configure-->execution"
    println "对 ${getName()} 进行配置"
    msg = 25
}
//该方法将会在配置阶段执行，所有在配置阶段执行的代码按照出现的先后顺序执行。
//configure代码块中把msg设置成数值25.这里又把msg设置成string的值，后面的把前面覆盖。
hello01.setProperty("msg", "我是小孩子")

//设置依赖的task，只有test1 task执行完后才会执行hello task
hello01.dependsOn(test01)
//设置终结者任务，执行完hello task之后会执行test2 task，通常可以用该方法做一些清理操作
hello01.finalizedBy(test02)
//如果同时执行hello、test3这2个task，会确保test3执行完之后才执行hello这个task，用这个来保证执行顺序
hello01.setMustRunAfter([test03])
/*设置满足某个条件后才执行该task..注意：该只有task中所有的Action要求满足这个条件才执行，
* 对于task的configure代码,也就是task的配置代码是不受影响的。它只影响action的执行*/
hello01.setOnlyIf {
    return hello01.property("age") == 70
}
